use std::{
	fs::File,
	io::{BufWriter, Write},
	path::Path,
	sync::OnceLock,
};

use regex::Regex;

fn main() -> UnitResult {
	let data_dir = std::env::var("DOOMLS_DATA_DIR")?;
	println!(r#"cargo:rerun-if-changed={data_dir}"#);
	let data_dir = Path::new(&data_dir);

	let out_dir = std::env::var("OUT_DIR")?;
	let out_native_dir = Path::new(&out_dir).join("native");
	std::fs::create_dir_all(&out_native_dir)?;

	zscript(data_dir, &out_native_dir)?;

	Ok(())
}

fn zscript(data_dir: &Path, out_native_dir: &Path) -> UnitResult {
	let out_zscript_file = out_native_dir.join("zscript.rs");
	let mut bw = BufWriter::new(std::fs::File::create(out_zscript_file)?);
	start_file(&mut bw)?;
	zscript_globals(&mut bw, data_dir)?;
	Ok(())
}

fn zscript_globals(bw: &mut BufWriter<File>, data_dir: &Path) -> UnitResult {
	let toml_global = {
		let p_global = data_dir.join("global.toml");
		let txt_global = std::fs::read_to_string(p_global)?;
		txt_global.parse::<toml::Table>()?
	};

	{
		start_function(bw, "native_global_functions")?;

		let instance_methods = toml_global
			.get("instance-methods")
			.unwrap()
			.as_table()
			.unwrap();

		category(instance_methods, |method| {
			let docs = sanitize_docs(method);
			let v_decl = method.get("decl").unwrap();

			if let Some(s_decl) = v_decl.as_str() {
				let (decl, name) = extract_decl_and_name(s_decl);
				format_function_datum(bw, name, &decl, docs)?;
			} else if let Some(t_decl) = v_decl.as_array() {
				for raw_decl in t_decl.iter().map(|v| v.as_str().unwrap()) {
					let (decl, name) = extract_decl_and_name(raw_decl);
					format_function_datum(bw, name, &decl, docs)?;
				}
			} else {
				unreachable!()
			}

			Ok(())
		})?;

		finish_function(bw)?;
	}

	{
		start_function(bw, "native_global_values")?;

		let instance_members = toml_global
			.get("instance-members")
			.unwrap()
			.as_table()
			.unwrap();

		category(instance_members, |member| {
			let docs = sanitize_docs(member);
			let v_decl = member.get("decl").unwrap();

			if let Some(s_decl) = v_decl.as_str() {
				let (decl, name) = extract_decl_and_name(s_decl);
				format_value_datum(bw, name, &decl, docs, "Constant")?;
			} else if let Some(t_decl) = v_decl.as_array() {
				for raw_decl in t_decl.iter().map(|v| v.as_str().unwrap()) {
					let (decl, name) = extract_decl_and_name(raw_decl);
					format_value_datum(bw, name, &decl, docs, "Constant")?;
				}
			} else {
				unreachable!()
			}

			Ok(())
		})?;

		let constants = toml_global.get("constants").unwrap().as_table().unwrap();

		category(constants, |constant| {
			let docs = sanitize_docs(constant);
			let v_decl = constant.get("decl").unwrap();

			if let Some(s_decl) = v_decl.as_str() {
				let (decl, name) = extract_decl_and_name(s_decl);
				format_value_datum(bw, name, &decl, docs, "Constant")?;
			} else if let Some(t_decl) = v_decl.as_array() {
				for raw_decl in t_decl.iter().map(|v| v.as_str().unwrap()) {
					let (decl, name) = extract_decl_and_name(raw_decl);
					format_value_datum(bw, name, &decl, docs, "Constant")?;
				}
			} else {
				unreachable!()
			}

			Ok(())
		})?;

		finish_function(bw)?;
	}

	Ok(())
}

// Details /////////////////////////////////////////////////////////////////////

type UnitResult = Result<(), Box<dyn std::error::Error>>;
type TomlTable = toml::map::Map<String, toml::Value>;

fn start_file(bw: &mut BufWriter<File>) -> UnitResult {
	write!(
		bw,
		r"// This file is auto-generated by a build script.

"
	)?;

	Ok(())
}

fn start_function(bw: &mut BufWriter<File>, name: &'static str) -> UnitResult {
	write!(
		bw,
		r"#[rustfmt::skip]
pub(crate) fn {name}(core: &crate::Core) -> impl Iterator<Item = (IName, Datum)> {{
	["
	)?;

	Ok(())
}

fn finish_function(bw: &mut BufWriter<File>) -> UnitResult {
	write!(
		bw,
		r"
	].into_iter()
}}"
	)?;

	writeln!(bw)?;

	Ok(())
}

/// A category is a section titled something like "Instance Methods", "Constants",
/// or "Variants". Each may or may not contain a table titled "groups" and another
/// titled "ungrouped".
fn category<F>(category: &TomlTable, mut callback: F) -> UnitResult
where
	F: FnMut(&TomlTable) -> UnitResult,
{
	let groups = category.get("groups").unwrap().as_table().unwrap();

	for group in groups.iter().map(|kvp| kvp.1.as_array().unwrap()) {
		for obj in group.iter().map(|value| value.as_table().unwrap()) {
			callback(obj)?;
		}
	}

	Ok(())
}

/// Essentially a no-op now, but shortens other code and may be useful later.
#[must_use]
fn sanitize_docs(table: &TomlTable) -> &str {
	table.get("docs").map(|d| d.as_str().unwrap()).unwrap_or("")
}

#[must_use]
fn extract_decl_and_name(decl: &str) -> (String, &str) {
	static RGX_NAME: OnceLock<Regex> = OnceLock::new();
	let rgx_name = RGX_NAME.get_or_init(|| Regex::new(r"\{([A-Za-z0-9_]+)\}").unwrap());

	let name = rgx_name
		.captures(decl)
		.map(|cap| cap.get(1).unwrap().as_str())
		.or_else(|| panic!("Failed to extract name from declaration: `{decl}`"))
		.unwrap();

	let mut pre_ret = String::with_capacity(decl.len());
	let mut last_match = 0;

	static RGX: OnceLock<Regex> = OnceLock::new();

	let rgx = RGX.get_or_init(|| Regex::new(r#"(?x)(\\\[)|(\\\])|\[|\]|\{|\}|(\\<)"#).unwrap());

	for capset in rgx.captures_iter(decl) {
		let (range, replacement) = if let Some(m) = capset.get(1) {
			(m.range(), "\x1A")
		} else if let Some(m) = capset.get(2) {
			(m.range(), "\x1B")
		} else if let Some(m) = capset.get(3) {
			(m.range(), "<")
		} else {
			let r = capset.get(0).unwrap().range();
			(r.clone(), &decl[last_match..r.start])
		};

		pre_ret.push_str(replacement);
		last_match = range.end;
	}

	let mut ret = pre_ret.clone();

	for (idx, _) in pre_ret.match_indices(|c| c == '\x1A') {
		ret.replace_range(idx..(idx + 1), "[");
	}

	for (idx, _) in pre_ret.match_indices(|c| c == '\x1B') {
		ret.replace_range(idx..(idx + 1), "]");
	}

	ret.push_str(&decl[last_match..]);

	(ret, name)
}

fn format_function_datum(
	bw: &mut BufWriter<File>,
	name: &str,
	decl: &str,
	docs: &str,
) -> UnitResult {
	write!(
		bw,
		r##"{{
	let iname = core.strings.value_name_nocase("{name}");

	(
		iname,
		Datum::Function(FunctionDatum {{
			name: iname,
			source: FunctionSource::Native {{
				signature: r#"{decl}"#,
				doc: r#"{docs}"#,
			}},
			is_const: true,
			is_static: false,
			body: None,
		}}),
	)
}},
"##
	)?;

	Ok(())
}

fn format_value_datum(
	bw: &mut BufWriter<File>,
	name: &str,
	decl: &str,
	docs: &str,
	kind: &'static str,
) -> UnitResult {
	write!(
		bw,
		r##"{{
	let iname = core.strings.value_name_nocase("{name}");

	(
		iname,
		Datum::Value(ValueDatum {{
			name: iname,
			source: ValueSource::Native {{
				decl: r#"{decl}"#,
				docs: r#"{docs}"#,
			}},
			kind: ValueKind::{kind},
		}}),
	)
}},
"##
	)?;

	Ok(())
}
